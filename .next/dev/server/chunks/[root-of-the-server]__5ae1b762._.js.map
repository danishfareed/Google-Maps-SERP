{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient }\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,sMAAY;AAElB,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/grid.ts"],"sourcesContent":["export interface GridPoint {\n    lat: number;\n    lng: number;\n    id?: string;\n}\n\nexport type GridShape = 'SQUARE' | 'CIRCLE' | 'ZIP' | 'SMART';\n\nexport function generateGrid(\n    centerLat: number,\n    centerLng: number,\n    radiusKm: number,\n    gridSize: number,\n    shape: GridShape = 'SQUARE'\n): GridPoint[] {\n    if (shape === 'CIRCLE') {\n        return generateCircleGrid(centerLat, centerLng, radiusKm, gridSize);\n    }\n\n    if (shape === 'ZIP') {\n        return generateZipGrid(centerLat, centerLng, radiusKm, gridSize);\n    }\n\n    if (shape === 'SMART') {\n        return generateSmartGrid(centerLat, centerLng, radiusKm);\n    }\n\n    const points: GridPoint[] = [];\n    const latDelta = radiusKm / 111.111;\n    const lngDelta = radiusKm / (111.111 * Math.cos(centerLat * (Math.PI / 180)));\n\n    const startLat = centerLat - latDelta;\n    const startLng = centerLng - lngDelta;\n\n    const latStep = (latDelta * 2) / (gridSize - 1);\n    const lngStep = (lngDelta * 2) / (gridSize - 1);\n\n    for (let i = 0; i < gridSize; i++) {\n        for (let j = 0; j < gridSize; j++) {\n            points.push({\n                lat: startLat + i * latStep,\n                lng: startLng + j * lngStep,\n                id: `sq-${i}-${j}`\n            });\n        }\n    }\n\n    return points;\n}\n\nfunction generateCircleGrid(centerLat: number, centerLng: number, radiusKm: number, gridSize: number): GridPoint[] {\n    const points: GridPoint[] = [];\n    points.push({ lat: centerLat, lng: centerLng, id: 'center' }); // Always include center\n\n    const rings = Math.floor(gridSize / 2);\n    if (rings < 1) return points;\n\n    for (let r = 1; r <= rings; r++) {\n        const ringRadius = (radiusKm * r) / rings;\n        const numPoints = r * 6; // Hexagonal-ish distribution\n\n        for (let i = 0; i < numPoints; i++) {\n            const angle = (i * 360) / numPoints;\n            const bearing = angle * (Math.PI / 180);\n\n            // Haversine-ish approximate offset\n            const latOffset = (ringRadius / 111.111) * Math.cos(bearing);\n            const lngOffset = (ringRadius / (111.111 * Math.cos(centerLat * (Math.PI / 180)))) * Math.sin(bearing);\n\n            points.push({\n                lat: centerLat + latOffset,\n                lng: centerLng + lngOffset,\n                id: `circle-${r}-${i}`\n            });\n        }\n    }\n\n    return points;\n}\n\nfunction generateZipGrid(centerLat: number, centerLng: number, radiusKm: number, gridSize: number): GridPoint[] {\n    const points: GridPoint[] = [];\n    // For Zip mode, we cluster pins semi-randomly but concentrated in sub-sectors\n    // In a real app, this would query a zip-code boundary API\n    const sectors = 4;\n    const pointsPerSector = Math.ceil((gridSize * gridSize) / sectors);\n\n    for (let s = 0; s < sectors; s++) {\n        const sectorAngle = (s * 360) / sectors;\n        const bearing = sectorAngle * (Math.PI / 180);\n\n        // Sector center\n        const sLat = centerLat + (radiusKm * 0.6 / 111.111) * Math.cos(bearing);\n        const sLng = centerLng + (radiusKm * 0.6 / (111.111 * Math.cos(centerLat * (Math.PI / 180)))) * Math.sin(bearing);\n\n        for (let i = 0; i < pointsPerSector; i++) {\n            const jitter = 0.2 * radiusKm;\n            const jLat = (Math.random() - 0.5) * jitter / 111.111;\n            const jLng = (Math.random() - 0.5) * jitter / (111.111 * Math.cos(sLat * (Math.PI / 180)));\n\n            points.push({\n                lat: sLat + jLat,\n                lng: sLng + jLng,\n                id: `zip-${s}-${i}`\n            });\n        }\n    }\n\n    return points;\n}\n\nfunction generateSmartGrid(centerLat: number, centerLng: number, radiusKm: number): GridPoint[] {\n    const points: GridPoint[] = [];\n    const R = 6371; // Earth's radius in km\n\n    // Smart grid focused on center\n    points.push({ lat: centerLat, lng: centerLng, id: 'smart-center' });\n\n    // Ring configuration: [distanceFromCenterInKm, pointSpacingInKm]\n    // We scale this based on the total radius requested\n    const ringConfigs = [\n        { dist: 0.15, spacing: 0.3 },\n        { dist: 0.4, spacing: 0.5 },\n        { dist: 0.8, spacing: 0.8 },\n        { dist: 1.5, spacing: 1.2 },\n        { dist: 3.0, spacing: 2.0 },\n        { dist: 6.0, spacing: 4.0 },\n        { dist: 12.0, spacing: 8.0 }\n    ];\n\n    ringConfigs.forEach((ring, ringIdx) => {\n        // Adjust ring distance relative to the requested radius\n        // If radius is 3km, we don't want points at 12km\n        if (ring.dist * (radiusKm / 3) > radiusKm && ringIdx > 1) return;\n\n        const actualDist = ring.dist * (radiusKm / 3);\n        const actualSpacing = ring.spacing * (radiusKm / 3);\n\n        const circumference = 2 * Math.PI * actualDist;\n        const numPoints = Math.max(3, Math.floor(circumference / actualSpacing));\n        const angleStep = (2 * Math.PI) / numPoints;\n\n        for (let i = 0; i < numPoints; i++) {\n            const angle = angleStep * i;\n            // Haversine approximation for small distances\n            const latOffset = (actualDist / 111.111) * Math.cos(angle);\n            const lngOffset = (actualDist / (111.111 * Math.cos(centerLat * (Math.PI / 180)))) * Math.sin(angle);\n\n            points.push({\n                lat: centerLat + latOffset,\n                lng: centerLng + lngOffset,\n                id: `smart-${ringIdx}-${i}`\n            });\n        }\n    });\n\n    return points;\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 211, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/scraper.ts"],"sourcesContent":["import { chromium, BrowserContext, Page } from 'playwright';\n\nexport interface ScrapeResult {\n    name: string;\n    rating?: number;\n    reviews?: number;\n    address?: string;\n    url?: string;\n    rank: number;\n}\n\nexport async function scrapeGMB(page: Page, keyword: string, lat: number, lng: number): Promise<ScrapeResult[]> {\n    try {\n        console.log(`[Scraper] Navigating to: https://www.google.com/maps/search/${keyword}/@${lat},${lng},14z/`);\n\n        // Use a 30s timeout for the initial load, wait for domcontentloaded\n        // If this fails, it's likely a dead proxy or a block\n        try {\n            await page.goto(`https://www.google.com/maps/search/${encodeURIComponent(keyword)}/@${lat},${lng},14z/`, {\n                waitUntil: 'domcontentloaded',\n                timeout: 30000,\n            });\n        } catch (gotoError: any) {\n            console.error(`[Scraper] Page goto failed: ${gotoError.message}`);\n            throw gotoError; // Rethrow to be caught by the scanner's retry logic\n        }\n\n        // Wait for results to load - use multiple common selectors\n        try {\n            await page.waitForFunction(() => {\n                return !!(document.querySelector('[role=\"article\"]') ||\n                    document.querySelector('.qBF1Pd') ||\n                    document.querySelector('[role=\"feed\"]'));\n            }, { timeout: 20000 });\n        } catch (e) {\n            console.log('[Scraper] Warning: Standard result selectors not found, trying fallback extraction anyway.');\n        }\n\n        // Mimic human scrolling behavior\n        for (let i = 0; i < 3; i++) {\n            await page.evaluate(() => {\n                const scrollable = document.querySelector('[role=\"feed\"]') || document.body;\n                scrollable.scrollBy(0, 800);\n            });\n            await page.waitForTimeout(1000 + Math.random() * 1000);\n        }\n\n        // Extract results with robust, multiple-path selectors\n        // We use a self-invoking function string to avoid any transpilation artifacts like __name\n        const results: ScrapeResult[] = await page.evaluate(() => {\n            const extracted: any[] = [];\n\n            // Priority 1: Articles with specific roles\n            let items = Array.from(document.querySelectorAll('div[role=\"article\"]'));\n\n            // Priority 2: Links that look like place profiles\n            if (items.length === 0) {\n                const links = Array.from(document.querySelectorAll('a[href*=\"/maps/place/\"]'));\n                items = links.map(l => l.closest('div') || l).filter(Boolean) as Element[];\n            }\n\n            const seenNames = new Set();\n\n            items.forEach((item) => {\n                if (extracted.length >= 20) return;\n\n                let name = '';\n                const ariaLabel = item.getAttribute('aria-label');\n                if (ariaLabel && !ariaLabel.includes('stars') && ariaLabel.length > 2) {\n                    name = ariaLabel;\n                }\n\n                // Strategy B: Specific class signatures\n                if (!name) {\n                    const nameEl = item.querySelector('.fontHeadlineSmall, .qBF1Pd, [role=\"heading\"]');\n                    name = nameEl?.textContent?.trim() || '';\n                }\n\n                if (!name || name.length < 2) return;\n                name = name.split(' Â· ')[0].replace(/\\. \\d+$/, '').trim();\n\n                if (seenNames.has(name.toLowerCase())) return;\n                seenNames.add(name.toLowerCase());\n\n                // URL/Link Extraction\n                const linkEl = item.querySelector('a[href*=\"/maps/place/\"]') || item.closest('a[href*=\"/maps/place/\"]');\n                const url = linkEl ? (linkEl as HTMLAnchorElement).href : '';\n\n                // Rating & Reviews extraction\n                const ratingEl = item.querySelector('[role=\"img\"][aria-label*=\"stars\"]');\n                const ratingLabel = ratingEl?.getAttribute('aria-label') || '';\n                const ratingMatch = ratingLabel.match(/([0-9.]+)\\s+stars/);\n                const rating = ratingMatch ? parseFloat(ratingMatch[1]) : undefined;\n\n                const reviewsMatch = ratingLabel.match(/\\(([\\d,]+)\\)/) || ratingLabel.match(/([\\d,]+)\\s+reviews/);\n                const reviews = reviewsMatch ? parseInt(reviewsMatch[1].replace(/,/g, '')) : 0;\n\n                const text = (item as HTMLElement).innerText || '';\n                const lines = text.split('\\n');\n                const address = lines.find(l => l.match(/\\d+/) && l !== name && l.length > 5) || '';\n\n                extracted.push({\n                    name,\n                    rating,\n                    reviews,\n                    address: address.trim(),\n                    url,\n                    rank: extracted.length + 1\n                });\n            });\n\n            return extracted;\n        });\n\n        console.log(`[Scraper] Successfully extracted ${results.length} results.`);\n        return results;\n\n    } catch (error) {\n        console.error(`[Scraper] Error scraping ${lat},${lng}:`, error);\n        throw error; // Re-throw to trigger scanner's retry/rotation logic\n    }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 312, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/scanner.ts"],"sourcesContent":["import { prisma } from './prisma';\nimport { generateGrid } from './grid';\nimport { scrapeGMB } from './scraper';\nimport { chromium } from 'playwright';\n\nexport async function runScan(scanId: string) {\n    const scan = await prisma.scan.findUnique({\n        where: { id: scanId },\n    });\n\n    if (!scan) throw new Error('Scan not found');\n\n    await prisma.scan.update({\n        where: { id: scanId },\n        data: { status: 'RUNNING' },\n    });\n\n    const points = scan.customPoints\n        ? JSON.parse(scan.customPoints)\n        : generateGrid(scan.centerLat, scan.centerLng, scan.radius, scan.gridSize, scan.shape as any);\n\n    // Initial fetch of proxy settings\n    const proxySetting = await (prisma as any).globalSetting.findUnique({ where: { key: 'useSystemProxy' } });\n    const useSystemProxy = proxySetting ? proxySetting.value === 'true' : true;\n\n    let browser: any = null;\n    let context: any = null;\n    let page: any = null;\n    let currentProxyId: string | null = null;\n\n    async function initBrowser(failedProxyId?: string) {\n        if (browser) await browser.close();\n\n        // If a proxy failed, mark it DEAD in the database immediately\n        if (failedProxyId) {\n            console.log(`[Scanner] Marking proxy ${failedProxyId} as DEAD due to connection failure.`);\n            try {\n                await (prisma as any).proxy.update({\n                    where: { id: failedProxyId },\n                    data: { status: 'DEAD', lastTestedAt: new Date() }\n                });\n            } catch (err) {\n                console.error('[Scanner] Failed to update proxy status:', err);\n            }\n        }\n\n        const launchOptions: any = { headless: true };\n\n        if (!useSystemProxy) {\n            // Fetch healthy proxies (ACTIVE or UNTESTED)\n            const availableProxies = await (prisma as any).proxy.findMany({\n                where: {\n                    enabled: true,\n                    status: { in: ['ACTIVE', 'UNTESTED'] }\n                }\n            });\n\n            if (availableProxies.length > 0) {\n                // Prioritize ACTIVE proxies if available, otherwise use UNTESTED\n                const activeOnes = availableProxies.filter((p: any) => p.status === 'ACTIVE');\n                const pool = activeOnes.length > 0 ? activeOnes : availableProxies;\n\n                const p = pool[Math.floor(Math.random() * pool.length)];\n                currentProxyId = p.id;\n\n                launchOptions.proxy = {\n                    server: `http://${p.host}:${p.port}`,\n                    username: p.username || undefined,\n                    password: p.password || undefined,\n                };\n                console.log(`[Scanner] Initializing with ${p.status} proxy: ${p.host}:${p.port}`);\n            } else {\n                console.log(`[Scanner] No healthy proxies available. Falling back to direct connection.`);\n            }\n        } else {\n            console.log(`[Scanner] Initializing Direct System Connection`);\n        }\n\n        browser = await chromium.launch(launchOptions);\n        context = await browser.newContext({\n            viewport: { width: 1280, height: 800 },\n            userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n        });\n        await context.grantPermissions(['geolocation']);\n        page = await context.newPage();\n    }\n\n    try {\n        await initBrowser();\n\n        for (const point of points) {\n            // Check if scan has been stopped\n            const currentScan = await prisma.scan.findUnique({\n                where: { id: scanId },\n                select: { status: true }\n            });\n\n            if (!currentScan || currentScan.status === 'STOPPED') {\n                console.log(`Scan ${scanId} was stopped.`);\n                break;\n            }\n\n            console.log(`Scraping point: ${point.lat}, ${point.lng}`);\n            let results: any[] = [];\n            let success = false;\n            let attempts = 0;\n            const maxAttempts = 3;\n\n            while (!success && attempts < maxAttempts) {\n                attempts++;\n                try {\n                    await context.setGeolocation({ latitude: point.lat, longitude: point.lng });\n                    results = await scrapeGMB(page, scan.keyword, point.lat, point.lng);\n                    success = true;\n                } catch (scrapeError: any) {\n                    console.error(`[Scanner] Attempt ${attempts} failed for point ${point.lat},${point.lng}: ${scrapeError.message}`);\n                    if (attempts < maxAttempts) {\n                        const isProxyError = scrapeError.message.includes('ERR_PROXY_CONNECTION_FAILED') ||\n                            scrapeError.message.includes('ERR_TUNNEL_CONNECTION_FAILED') ||\n                            scrapeError.message.includes('TIMEOUT');\n\n                        console.log(`[Scanner] Retrying with new proxy rotation...`);\n                        await initBrowser(isProxyError ? (currentProxyId || undefined) : undefined);\n                    }\n                }\n            }\n\n            if (!success) {\n                console.error(`[Scanner] Failed to scrape point ${point.lat},${point.lng} after ${maxAttempts} attempts.`);\n                // We create a result with empty data to allow the scan to continue but show the failure\n                await prisma.result.create({\n                    data: {\n                        scanId: scan.id,\n                        lat: point.lat,\n                        lng: point.lng,\n                        topResults: JSON.stringify([]),\n                        rank: null,\n                    },\n                });\n                continue;\n            }\n\n            let rank = null;\n            let targetName = null;\n\n            if (scan.businessName) {\n                const match = results.find(r => r.name.toLowerCase().includes(scan.businessName!.toLowerCase()));\n                if (match) {\n                    rank = match.rank;\n                    targetName = match.name;\n                }\n            }\n\n            await prisma.result.create({\n                data: {\n                    scanId: scan.id,\n                    lat: point.lat,\n                    lng: point.lng,\n                    topResults: JSON.stringify(results),\n                    rank,\n                    targetName\n                },\n            });\n\n            // Random delay between points\n            await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));\n        }\n\n        // Calculate NEXT RUN if recurring\n        let nextRun = null;\n        if (scan.frequency === 'DAILY') {\n            nextRun = new Date(Date.now() + 24 * 60 * 60 * 1000);\n        } else if (scan.frequency === 'WEEKLY') {\n            nextRun = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000);\n        }\n\n        // Check for rank changes and create alerts\n        if (scan.businessName) {\n            const previousScan = await (prisma as any).scan.findFirst({\n                where: {\n                    keyword: scan.keyword,\n                    businessName: scan.businessName,\n                    status: 'COMPLETED',\n                    id: { not: scanId }\n                },\n                orderBy: { createdAt: 'desc' },\n                include: { results: true }\n            });\n\n            if (previousScan) {\n                const currentResults = await prisma.result.findMany({ where: { scanId } });\n                const currentAvg = currentResults.filter(r => r.rank !== null).reduce((acc, r) => acc + (r.rank || 21), 0) / (currentResults.filter(r => r.rank !== null).length || 1);\n                const previousAvg = previousScan.results.filter(r => r.rank !== null).reduce((acc, r) => acc + (r.rank || 21), 0) / (previousScan.results.filter(r => r.rank !== null).length || 1);\n\n                const diff = previousAvg - currentAvg;\n                if (Math.abs(diff) >= 0.5) {\n                    await (prisma as any).alert.create({\n                        data: {\n                            type: diff > 0 ? 'RANK_UP' : 'RANK_DOWN',\n                            message: `${scan.businessName} rank ${diff > 0 ? 'improved' : 'dropped'} by ${Math.abs(diff).toFixed(1)} points for \"${scan.keyword}\"`,\n                            scanId: scan.id\n                        }\n                    });\n                }\n            }\n        }\n\n        await (prisma as any).scan.update({\n            where: { id: scanId },\n            data: {\n                status: 'COMPLETED',\n                nextRun\n            },\n        });\n\n    } catch (error) {\n        console.error(`[Scanner] Critical failure in scan ${scanId}:`, error);\n        await prisma.scan.update({\n            where: { id: scanId },\n            data: { status: 'FAILED' },\n        });\n\n        await (prisma as any).alert.create({\n            data: {\n                type: 'SCAN_ERROR',\n                message: `Scan failed for \"${scan.keyword}\": ${error instanceof Error ? error.message : String(error)}`,\n                scanId: scanId\n            }\n        });\n    } finally {\n        if (browser) await browser.close();\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;;;;;AAEO,eAAe,QAAQ,MAAc;IACxC,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACtC,OAAO;YAAE,IAAI;QAAO;IACxB;IAEA,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;IAE3B,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;QACrB,OAAO;YAAE,IAAI;QAAO;QACpB,MAAM;YAAE,QAAQ;QAAU;IAC9B;IAEA,MAAM,SAAS,KAAK,YAAY,GAC1B,KAAK,KAAK,CAAC,KAAK,YAAY,IAC5B,IAAA,oIAAY,EAAC,KAAK,SAAS,EAAE,KAAK,SAAS,EAAE,KAAK,MAAM,EAAE,KAAK,QAAQ,EAAE,KAAK,KAAK;IAEzF,kCAAkC;IAClC,MAAM,eAAe,MAAM,AAAC,gIAAM,CAAS,aAAa,CAAC,UAAU,CAAC;QAAE,OAAO;YAAE,KAAK;QAAiB;IAAE;IACvG,MAAM,iBAAiB,eAAe,aAAa,KAAK,KAAK,SAAS;IAEtE,IAAI,UAAe;IACnB,IAAI,UAAe;IACnB,IAAI,OAAY;IAChB,IAAI,iBAAgC;IAEpC,eAAe,YAAY,aAAsB;QAC7C,IAAI,SAAS,MAAM,QAAQ,KAAK;QAEhC,8DAA8D;QAC9D,IAAI,eAAe;YACf,QAAQ,GAAG,CAAC,CAAC,wBAAwB,EAAE,cAAc,mCAAmC,CAAC;YACzF,IAAI;gBACA,MAAM,AAAC,gIAAM,CAAS,KAAK,CAAC,MAAM,CAAC;oBAC/B,OAAO;wBAAE,IAAI;oBAAc;oBAC3B,MAAM;wBAAE,QAAQ;wBAAQ,cAAc,IAAI;oBAAO;gBACrD;YACJ,EAAE,OAAO,KAAK;gBACV,QAAQ,KAAK,CAAC,4CAA4C;YAC9D;QACJ;QAEA,MAAM,gBAAqB;YAAE,UAAU;QAAK;QAE5C,IAAI,CAAC,gBAAgB;YACjB,6CAA6C;YAC7C,MAAM,mBAAmB,MAAM,AAAC,gIAAM,CAAS,KAAK,CAAC,QAAQ,CAAC;gBAC1D,OAAO;oBACH,SAAS;oBACT,QAAQ;wBAAE,IAAI;4BAAC;4BAAU;yBAAW;oBAAC;gBACzC;YACJ;YAEA,IAAI,iBAAiB,MAAM,GAAG,GAAG;gBAC7B,iEAAiE;gBACjE,MAAM,aAAa,iBAAiB,MAAM,CAAC,CAAC,IAAW,EAAE,MAAM,KAAK;gBACpE,MAAM,OAAO,WAAW,MAAM,GAAG,IAAI,aAAa;gBAElD,MAAM,IAAI,IAAI,CAAC,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,KAAK,MAAM,EAAE;gBACvD,iBAAiB,EAAE,EAAE;gBAErB,cAAc,KAAK,GAAG;oBAClB,QAAQ,CAAC,OAAO,EAAE,EAAE,IAAI,CAAC,CAAC,EAAE,EAAE,IAAI,EAAE;oBACpC,UAAU,EAAE,QAAQ,IAAI;oBACxB,UAAU,EAAE,QAAQ,IAAI;gBAC5B;gBACA,QAAQ,GAAG,CAAC,CAAC,4BAA4B,EAAE,EAAE,MAAM,CAAC,QAAQ,EAAE,EAAE,IAAI,CAAC,CAAC,EAAE,EAAE,IAAI,EAAE;YACpF,OAAO;gBACH,QAAQ,GAAG,CAAC,CAAC,0EAA0E,CAAC;YAC5F;QACJ,OAAO;YACH,QAAQ,GAAG,CAAC,CAAC,+CAA+C,CAAC;QACjE;QAEA,UAAU,MAAM,iLAAQ,CAAC,MAAM,CAAC;QAChC,UAAU,MAAM,QAAQ,UAAU,CAAC;YAC/B,UAAU;gBAAE,OAAO;gBAAM,QAAQ;YAAI;YACrC,WAAW;QACf;QACA,MAAM,QAAQ,gBAAgB,CAAC;YAAC;SAAc;QAC9C,OAAO,MAAM,QAAQ,OAAO;IAChC;IAEA,IAAI;QACA,MAAM;QAEN,KAAK,MAAM,SAAS,OAAQ;YACxB,iCAAiC;YACjC,MAAM,cAAc,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;gBAC7C,OAAO;oBAAE,IAAI;gBAAO;gBACpB,QAAQ;oBAAE,QAAQ;gBAAK;YAC3B;YAEA,IAAI,CAAC,eAAe,YAAY,MAAM,KAAK,WAAW;gBAClD,QAAQ,GAAG,CAAC,CAAC,KAAK,EAAE,OAAO,aAAa,CAAC;gBACzC;YACJ;YAEA,QAAQ,GAAG,CAAC,CAAC,gBAAgB,EAAE,MAAM,GAAG,CAAC,EAAE,EAAE,MAAM,GAAG,EAAE;YACxD,IAAI,UAAiB,EAAE;YACvB,IAAI,UAAU;YACd,IAAI,WAAW;YACf,MAAM,cAAc;YAEpB,MAAO,CAAC,WAAW,WAAW,YAAa;gBACvC;gBACA,IAAI;oBACA,MAAM,QAAQ,cAAc,CAAC;wBAAE,UAAU,MAAM,GAAG;wBAAE,WAAW,MAAM,GAAG;oBAAC;oBACzE,UAAU,MAAM,IAAA,oIAAS,EAAC,MAAM,KAAK,OAAO,EAAE,MAAM,GAAG,EAAE,MAAM,GAAG;oBAClE,UAAU;gBACd,EAAE,OAAO,aAAkB;oBACvB,QAAQ,KAAK,CAAC,CAAC,kBAAkB,EAAE,SAAS,kBAAkB,EAAE,MAAM,GAAG,CAAC,CAAC,EAAE,MAAM,GAAG,CAAC,EAAE,EAAE,YAAY,OAAO,EAAE;oBAChH,IAAI,WAAW,aAAa;wBACxB,MAAM,eAAe,YAAY,OAAO,CAAC,QAAQ,CAAC,kCAC9C,YAAY,OAAO,CAAC,QAAQ,CAAC,mCAC7B,YAAY,OAAO,CAAC,QAAQ,CAAC;wBAEjC,QAAQ,GAAG,CAAC,CAAC,6CAA6C,CAAC;wBAC3D,MAAM,YAAY,eAAgB,kBAAkB,YAAa;oBACrE;gBACJ;YACJ;YAEA,IAAI,CAAC,SAAS;gBACV,QAAQ,KAAK,CAAC,CAAC,iCAAiC,EAAE,MAAM,GAAG,CAAC,CAAC,EAAE,MAAM,GAAG,CAAC,OAAO,EAAE,YAAY,UAAU,CAAC;gBACzG,wFAAwF;gBACxF,MAAM,gIAAM,CAAC,MAAM,CAAC,MAAM,CAAC;oBACvB,MAAM;wBACF,QAAQ,KAAK,EAAE;wBACf,KAAK,MAAM,GAAG;wBACd,KAAK,MAAM,GAAG;wBACd,YAAY,KAAK,SAAS,CAAC,EAAE;wBAC7B,MAAM;oBACV;gBACJ;gBACA;YACJ;YAEA,IAAI,OAAO;YACX,IAAI,aAAa;YAEjB,IAAI,KAAK,YAAY,EAAE;gBACnB,MAAM,QAAQ,QAAQ,IAAI,CAAC,CAAA,IAAK,EAAE,IAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,KAAK,YAAY,CAAE,WAAW;gBAC5F,IAAI,OAAO;oBACP,OAAO,MAAM,IAAI;oBACjB,aAAa,MAAM,IAAI;gBAC3B;YACJ;YAEA,MAAM,gIAAM,CAAC,MAAM,CAAC,MAAM,CAAC;gBACvB,MAAM;oBACF,QAAQ,KAAK,EAAE;oBACf,KAAK,MAAM,GAAG;oBACd,KAAK,MAAM,GAAG;oBACd,YAAY,KAAK,SAAS,CAAC;oBAC3B;oBACA;gBACJ;YACJ;YAEA,8BAA8B;YAC9B,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS,OAAO,KAAK,MAAM,KAAK;QAC5E;QAEA,kCAAkC;QAClC,IAAI,UAAU;QACd,IAAI,KAAK,SAAS,KAAK,SAAS;YAC5B,UAAU,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK;QACnD,OAAO,IAAI,KAAK,SAAS,KAAK,UAAU;YACpC,UAAU,IAAI,KAAK,KAAK,GAAG,KAAK,IAAI,KAAK,KAAK,KAAK;QACvD;QAEA,2CAA2C;QAC3C,IAAI,KAAK,YAAY,EAAE;YACnB,MAAM,eAAe,MAAM,AAAC,gIAAM,CAAS,IAAI,CAAC,SAAS,CAAC;gBACtD,OAAO;oBACH,SAAS,KAAK,OAAO;oBACrB,cAAc,KAAK,YAAY;oBAC/B,QAAQ;oBACR,IAAI;wBAAE,KAAK;oBAAO;gBACtB;gBACA,SAAS;oBAAE,WAAW;gBAAO;gBAC7B,SAAS;oBAAE,SAAS;gBAAK;YAC7B;YAEA,IAAI,cAAc;gBACd,MAAM,iBAAiB,MAAM,gIAAM,CAAC,MAAM,CAAC,QAAQ,CAAC;oBAAE,OAAO;wBAAE;oBAAO;gBAAE;gBACxE,MAAM,aAAa,eAAe,MAAM,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK,MAAM,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,CAAC,EAAE,IAAI,IAAI,EAAE,GAAG,KAAK,CAAC,eAAe,MAAM,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK,MAAM,MAAM,IAAI,CAAC;gBACrK,MAAM,cAAc,aAAa,OAAO,CAAC,MAAM,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK,MAAM,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,CAAC,EAAE,IAAI,IAAI,EAAE,GAAG,KAAK,CAAC,aAAa,OAAO,CAAC,MAAM,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK,MAAM,MAAM,IAAI,CAAC;gBAElL,MAAM,OAAO,cAAc;gBAC3B,IAAI,KAAK,GAAG,CAAC,SAAS,KAAK;oBACvB,MAAM,AAAC,gIAAM,CAAS,KAAK,CAAC,MAAM,CAAC;wBAC/B,MAAM;4BACF,MAAM,OAAO,IAAI,YAAY;4BAC7B,SAAS,GAAG,KAAK,YAAY,CAAC,MAAM,EAAE,OAAO,IAAI,aAAa,UAAU,IAAI,EAAE,KAAK,GAAG,CAAC,MAAM,OAAO,CAAC,GAAG,aAAa,EAAE,KAAK,OAAO,CAAC,CAAC,CAAC;4BACtI,QAAQ,KAAK,EAAE;wBACnB;oBACJ;gBACJ;YACJ;QACJ;QAEA,MAAM,AAAC,gIAAM,CAAS,IAAI,CAAC,MAAM,CAAC;YAC9B,OAAO;gBAAE,IAAI;YAAO;YACpB,MAAM;gBACF,QAAQ;gBACR;YACJ;QACJ;IAEJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,mCAAmC,EAAE,OAAO,CAAC,CAAC,EAAE;QAC/D,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YACrB,OAAO;gBAAE,IAAI;YAAO;YACpB,MAAM;gBAAE,QAAQ;YAAS;QAC7B;QAEA,MAAM,AAAC,gIAAM,CAAS,KAAK,CAAC,MAAM,CAAC;YAC/B,MAAM;gBACF,MAAM;gBACN,SAAS,CAAC,iBAAiB,EAAE,KAAK,OAAO,CAAC,GAAG,EAAE,iBAAiB,QAAQ,MAAM,OAAO,GAAG,OAAO,QAAQ;gBACvG,QAAQ;YACZ;QACJ;IACJ,SAAU;QACN,IAAI,SAAS,MAAM,QAAQ,KAAK;IACpC;AACJ"}},
    {"offset": {"line": 578, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/app/api/scans/route.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma';\nimport { NextResponse } from 'next/server';\nimport { runScan } from '@/lib/scanner';\n\nexport async function GET() {\n    try {\n        const scans = await prisma.scan.findMany({\n            orderBy: { createdAt: 'desc' },\n        });\n        return NextResponse.json({ scans });\n    } catch (error) {\n        console.error('Scans GET error:', error);\n        return NextResponse.json({ scans: [] });\n    }\n}\n\nexport async function POST(req: Request) {\n    try {\n        const {\n            keyword,\n            radius,\n            gridSize,\n            frequency,\n            businessName,\n            shape,\n            customPoints,\n            lat,\n            lng\n        } = await req.json();\n\n        // Use provided coordinates or default to Chicago (Mock)\n        const centerLat = lat || 41.8781;\n        const centerLng = lng || -87.6298;\n\n        const scan = await prisma.scan.create({\n            data: {\n                keyword,\n                centerLat,\n                centerLng,\n                radius: parseFloat(radius) || 5,\n                gridSize: parseInt(gridSize) || 3,\n                shape: shape || 'SQUARE',\n                customPoints: customPoints ? JSON.stringify(customPoints) : null,\n                frequency: frequency || 'ONCE',\n                businessName: businessName || undefined,\n                status: 'PENDING',\n            },\n        });\n\n        // Start scan in background\n        runScan(scan.id).catch(console.error);\n\n        return NextResponse.json(scan);\n    } catch (error) {\n        console.error('Scan creation CRITICAL error:', error);\n        if (error instanceof Error) {\n            console.error('Error message:', error.message);\n            console.error('Error stack:', error.stack);\n        }\n        return NextResponse.json({ error: 'Failed to create scan', details: String(error) }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;;;;;AAEO,eAAe;IAClB,IAAI;QACA,MAAM,QAAQ,MAAM,gIAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;YACrC,SAAS;gBAAE,WAAW;YAAO;QACjC;QACA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE;QAAM;IACrC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,oBAAoB;QAClC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,EAAE;QAAC;IACzC;AACJ;AAEO,eAAe,KAAK,GAAY;IACnC,IAAI;QACA,MAAM,EACF,OAAO,EACP,MAAM,EACN,QAAQ,EACR,SAAS,EACT,YAAY,EACZ,KAAK,EACL,YAAY,EACZ,GAAG,EACH,GAAG,EACN,GAAG,MAAM,IAAI,IAAI;QAElB,wDAAwD;QACxD,MAAM,YAAY,OAAO;QACzB,MAAM,YAAY,OAAO,CAAC;QAE1B,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YAClC,MAAM;gBACF;gBACA;gBACA;gBACA,QAAQ,WAAW,WAAW;gBAC9B,UAAU,SAAS,aAAa;gBAChC,OAAO,SAAS;gBAChB,cAAc,eAAe,KAAK,SAAS,CAAC,gBAAgB;gBAC5D,WAAW,aAAa;gBACxB,cAAc,gBAAgB;gBAC9B,QAAQ;YACZ;QACJ;QAEA,2BAA2B;QAC3B,IAAA,kIAAO,EAAC,KAAK,EAAE,EAAE,KAAK,CAAC,QAAQ,KAAK;QAEpC,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,iCAAiC;QAC/C,IAAI,iBAAiB,OAAO;YACxB,QAAQ,KAAK,CAAC,kBAAkB,MAAM,OAAO;YAC7C,QAAQ,KAAK,CAAC,gBAAgB,MAAM,KAAK;QAC7C;QACA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;YAAyB,SAAS,OAAO;QAAO,GAAG;YAAE,QAAQ;QAAI;IACvG;AACJ"}}]
}