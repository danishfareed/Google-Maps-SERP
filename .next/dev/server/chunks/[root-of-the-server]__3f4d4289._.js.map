{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient }\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,sMAAY;AAElB,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/app/api/scans/%5Bid%5D/route.ts"],"sourcesContent":["import { prisma } from '@/lib/prisma';\nimport { NextResponse } from 'next/server';\n\nexport async function GET(\n    request: Request,\n    { params }: { params: Promise<{ id: string }> }\n) {\n    try {\n        const { id } = await params;\n\n        const scan = await (prisma as any).scan.findUnique({\n            where: { id },\n            include: { results: true },\n        });\n\n        if (!scan) {\n            return NextResponse.json({ error: 'Scan not found' }, { status: 404 });\n        }\n\n        return NextResponse.json({ scan });\n    } catch (error) {\n        console.error('Scan GET error:', error);\n        return NextResponse.json({ error: 'Failed to fetch scan' }, { status: 500 });\n    }\n}\n\nexport async function DELETE(\n    request: Request,\n    { params }: { params: Promise<{ id: string }> }\n) {\n    try {\n        const { id } = await params;\n        await prisma.result.deleteMany({ where: { scanId: id } });\n        await prisma.scan.delete({ where: { id } });\n        return NextResponse.json({ success: true });\n    } catch (error) {\n        console.error('Scan DELETE error:', error);\n        return NextResponse.json({ error: 'Failed to delete scan' }, { status: 500 });\n    }\n}\n\nexport async function PATCH(\n    request: Request,\n    { params }: { params: Promise<{ id: string }> }\n) {\n    try {\n        const { id } = await params;\n        const body = await request.json();\n\n        const scan = await prisma.scan.update({\n            where: { id },\n            data: body,\n        });\n\n        return NextResponse.json(scan);\n    } catch (error) {\n        console.error('Scan PATCH error:', error);\n        return NextResponse.json({ error: 'Failed to update scan' }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEO,eAAe,IAClB,OAAgB,EAChB,EAAE,MAAM,EAAuC;IAE/C,IAAI;QACA,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;QAErB,MAAM,OAAO,MAAM,AAAC,gIAAM,CAAS,IAAI,CAAC,UAAU,CAAC;YAC/C,OAAO;gBAAE;YAAG;YACZ,SAAS;gBAAE,SAAS;YAAK;QAC7B;QAEA,IAAI,CAAC,MAAM;YACP,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAiB,GAAG;gBAAE,QAAQ;YAAI;QACxE;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE;QAAK;IACpC,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,mBAAmB;QACjC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAuB,GAAG;YAAE,QAAQ;QAAI;IAC9E;AACJ;AAEO,eAAe,OAClB,OAAgB,EAChB,EAAE,MAAM,EAAuC;IAE/C,IAAI;QACA,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;QACrB,MAAM,gIAAM,CAAC,MAAM,CAAC,UAAU,CAAC;YAAE,OAAO;gBAAE,QAAQ;YAAG;QAAE;QACvD,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YAAE,OAAO;gBAAE;YAAG;QAAE;QACzC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAK;IAC7C,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,sBAAsB;QACpC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACJ;AAEO,eAAe,MAClB,OAAgB,EAChB,EAAE,MAAM,EAAuC;IAE/C,IAAI;QACA,MAAM,EAAE,EAAE,EAAE,GAAG,MAAM;QACrB,MAAM,OAAO,MAAM,QAAQ,IAAI;QAE/B,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YAClC,OAAO;gBAAE;YAAG;YACZ,MAAM;QACV;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,qBAAqB;QACnC,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACJ"}}]
}