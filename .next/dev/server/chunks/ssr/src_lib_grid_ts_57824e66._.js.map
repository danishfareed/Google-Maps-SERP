{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/grid.ts"],"sourcesContent":["export interface GridPoint {\n    lat: number;\n    lng: number;\n    id?: string;\n}\n\nexport type GridShape = 'SQUARE' | 'CIRCLE' | 'ZIP' | 'SMART';\n\nexport function generateGrid(\n    centerLat: number,\n    centerLng: number,\n    radiusKm: number,\n    gridSize: number,\n    shape: GridShape = 'SQUARE'\n): GridPoint[] {\n    if (shape === 'CIRCLE') {\n        return generateCircleGrid(centerLat, centerLng, radiusKm, gridSize);\n    }\n\n    if (shape === 'ZIP') {\n        return generateZipGrid(centerLat, centerLng, radiusKm, gridSize);\n    }\n\n    if (shape === 'SMART') {\n        return generateSmartGrid(centerLat, centerLng, radiusKm);\n    }\n\n    const points: GridPoint[] = [];\n    const latDelta = radiusKm / 111.111;\n    const lngDelta = radiusKm / (111.111 * Math.cos(centerLat * (Math.PI / 180)));\n\n    const startLat = centerLat - latDelta;\n    const startLng = centerLng - lngDelta;\n\n    const latStep = gridSize > 1 ? (latDelta * 2) / (gridSize - 1) : 0;\n    const lngStep = gridSize > 1 ? (lngDelta * 2) / (gridSize - 1) : 0;\n\n    for (let i = 0; i < gridSize; i++) {\n        for (let j = 0; j < gridSize; j++) {\n            points.push({\n                lat: startLat + i * latStep,\n                lng: startLng + j * lngStep,\n                id: `sq-${i}-${j}`\n            });\n        }\n    }\n\n    return points;\n}\n\nfunction generateCircleGrid(centerLat: number, centerLng: number, radiusKm: number, gridSize: number): GridPoint[] {\n    const points: GridPoint[] = [];\n    points.push({ lat: centerLat, lng: centerLng, id: 'center' }); // Always include center\n\n    const rings = Math.floor(gridSize / 2);\n    if (rings < 1) return points;\n\n    for (let r = 1; r <= rings; r++) {\n        const ringRadius = (radiusKm * r) / rings;\n        const numPoints = r * 6; // Hexagonal-ish distribution\n\n        for (let i = 0; i < numPoints; i++) {\n            const angle = (i * 360) / numPoints;\n            const bearing = angle * (Math.PI / 180);\n\n            // Haversine-ish approximate offset\n            const latOffset = (ringRadius / 111.111) * Math.cos(bearing);\n            const lngOffset = (ringRadius / (111.111 * Math.cos(centerLat * (Math.PI / 180)))) * Math.sin(bearing);\n\n            points.push({\n                lat: centerLat + latOffset,\n                lng: centerLng + lngOffset,\n                id: `circle-${r}-${i}`\n            });\n        }\n    }\n\n    return points;\n}\n\nfunction generateZipGrid(centerLat: number, centerLng: number, radiusKm: number, gridSize: number): GridPoint[] {\n    const points: GridPoint[] = [];\n    // For Zip mode, we cluster pins semi-randomly but concentrated in sub-sectors\n    // In a real app, this would query a zip-code boundary API\n    const sectors = 4;\n    const pointsPerSector = Math.ceil((gridSize * gridSize) / sectors);\n\n    for (let s = 0; s < sectors; s++) {\n        const sectorAngle = (s * 360) / sectors;\n        const bearing = sectorAngle * (Math.PI / 180);\n\n        // Sector center\n        const sLat = centerLat + (radiusKm * 0.6 / 111.111) * Math.cos(bearing);\n        const sLng = centerLng + (radiusKm * 0.6 / (111.111 * Math.cos(centerLat * (Math.PI / 180)))) * Math.sin(bearing);\n\n        for (let i = 0; i < pointsPerSector; i++) {\n            const jitter = 0.2 * radiusKm;\n            const jLat = (Math.random() - 0.5) * jitter / 111.111;\n            const jLng = (Math.random() - 0.5) * jitter / (111.111 * Math.cos(sLat * (Math.PI / 180)));\n\n            points.push({\n                lat: sLat + jLat,\n                lng: sLng + jLng,\n                id: `zip-${s}-${i}`\n            });\n        }\n    }\n\n    return points;\n}\n\nfunction generateSmartGrid(centerLat: number, centerLng: number, radiusKm: number): GridPoint[] {\n    const points: GridPoint[] = [];\n    const R = 6371; // Earth's radius in km\n\n    // Smart grid focused on center\n    points.push({ lat: centerLat, lng: centerLng, id: 'smart-center' });\n\n    // Ring configuration: [distanceFromCenterInKm, pointSpacingInKm]\n    // We scale this based on the total radius requested\n    const ringConfigs = [\n        { dist: 0.15, spacing: 0.3 },\n        { dist: 0.4, spacing: 0.5 },\n        { dist: 0.8, spacing: 0.8 },\n        { dist: 1.5, spacing: 1.2 },\n        { dist: 3.0, spacing: 2.0 },\n        { dist: 6.0, spacing: 4.0 },\n        { dist: 12.0, spacing: 8.0 }\n    ];\n\n    ringConfigs.forEach((ring, ringIdx) => {\n        // Adjust ring distance relative to the requested radius\n        // If radius is 3km, we don't want points at 12km\n        if (ring.dist * (radiusKm / 3) > radiusKm && ringIdx > 1) return;\n\n        const actualDist = ring.dist * (radiusKm / 3);\n        const actualSpacing = ring.spacing * (radiusKm / 3);\n\n        const circumference = 2 * Math.PI * actualDist;\n        const numPoints = Math.max(3, Math.floor(circumference / actualSpacing));\n        const angleStep = (2 * Math.PI) / numPoints;\n\n        for (let i = 0; i < numPoints; i++) {\n            const angle = angleStep * i;\n            // Haversine approximation for small distances\n            const latOffset = (actualDist / 111.111) * Math.cos(angle);\n            const lngOffset = (actualDist / (111.111 * Math.cos(centerLat * (Math.PI / 180)))) * Math.sin(angle);\n\n            points.push({\n                lat: centerLat + latOffset,\n                lng: centerLng + lngOffset,\n                id: `smart-${ringIdx}-${i}`\n            });\n        }\n    });\n\n    return points;\n}\n"],"names":[],"mappings":"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"}}]
}