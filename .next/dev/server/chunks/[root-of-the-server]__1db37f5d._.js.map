{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = global as unknown as { prisma: PrismaClient }\n\nexport const prisma =\n  globalForPrisma.prisma ||\n  new PrismaClient()\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM;AAEC,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,sMAAY;AAElB,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 59, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/grid.ts"],"sourcesContent":["export interface GridPoint {\n    lat: number;\n    lng: number;\n}\n\nexport function generateGrid(centerLat: number, centerLng: number, radiusKm: number, gridSize: number): GridPoint[] {\n    const points: GridPoint[] = [];\n\n    // 1 degree of latitude is ~111.111 km\n    const latDelta = radiusKm / 111.111;\n    // 1 degree of longitude is ~111.111 * cos(lat) km\n    const lngDelta = radiusKm / (111.111 * Math.cos(centerLat * (Math.PI / 180)));\n\n    const startLat = centerLat - latDelta;\n    const startLng = centerLng - lngDelta;\n\n    const latStep = (latDelta * 2) / (gridSize - 1);\n    const lngStep = (lngDelta * 2) / (gridSize - 1);\n\n    for (let i = 0; i < gridSize; i++) {\n        for (let j = 0; j < gridSize; j++) {\n            points.push({\n                lat: startLat + i * latStep,\n                lng: startLng + j * lngStep,\n            });\n        }\n    }\n\n    return points;\n}\n"],"names":[],"mappings":";;;;AAKO,SAAS,aAAa,SAAiB,EAAE,SAAiB,EAAE,QAAgB,EAAE,QAAgB;IACjG,MAAM,SAAsB,EAAE;IAE9B,sCAAsC;IACtC,MAAM,WAAW,WAAW;IAC5B,kDAAkD;IAClD,MAAM,WAAW,WAAW,CAAC,UAAU,KAAK,GAAG,CAAC,YAAY,CAAC,KAAK,EAAE,GAAG,GAAG,EAAE;IAE5E,MAAM,WAAW,YAAY;IAC7B,MAAM,WAAW,YAAY;IAE7B,MAAM,UAAU,AAAC,WAAW,IAAK,CAAC,WAAW,CAAC;IAC9C,MAAM,UAAU,AAAC,WAAW,IAAK,CAAC,WAAW,CAAC;IAE9C,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,IAAK;QAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,IAAK;YAC/B,OAAO,IAAI,CAAC;gBACR,KAAK,WAAW,IAAI;gBACpB,KAAK,WAAW,IAAI;YACxB;QACJ;IACJ;IAEA,OAAO;AACX"}},
    {"offset": {"line": 89, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/scraper.ts"],"sourcesContent":["import { chromium, BrowserContext, Page } from 'playwright';\n\nexport interface ScrapeResult {\n    name: string;\n    rating?: number;\n    reviews?: number;\n    address?: string;\n    rank: number;\n}\n\nexport async function scrapeGMB(keyword: string, lat: number, lng: number): Promise<ScrapeResult[]> {\n    const browser = await chromium.launch({ headless: true });\n    const context = await browser.newContext({\n        viewport: { width: 1280, height: 800 },\n        userAgent: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n    });\n\n    // Grant geolocation permissions\n    await context.grantPermissions(['geolocation']);\n    await context.setGeolocation({ latitude: lat, longitude: lng });\n\n    const page = await context.newPage();\n\n    try {\n        // Navigate to Google Maps\n        await page.goto(`https://www.google.com/maps/search/${encodeURIComponent(keyword)}/@${lat},${lng},14z/`, {\n            waitUntil: 'networkidle',\n            timeout: 60000,\n        });\n\n        // Wait for the results list to appear - try multiple possible selectors\n        try {\n            await page.waitForSelector('[role=\"feed\"]', { timeout: 15000 });\n        } catch (e) {\n            console.log('Feed not found immediately, trying to interact...');\n        }\n\n        // Scroll to load more results (mimic user behavior)\n        const feedSelector = '[role=\"feed\"]';\n        for (let i = 0; i < 4; i++) {\n            const feed = await page.$(feedSelector);\n            if (feed) {\n                await feed.evaluate(node => node.scrollTop += 2000);\n            }\n            await page.waitForTimeout(1000 + Math.random() * 2000);\n        }\n\n        // Extract results using more generic structure assumptions\n        const results: ScrapeResult[] = await page.evaluate(() => {\n            // Helper to find text safely\n            const getText = (el: Element | null) => el?.textContent?.trim() || '';\n\n            const items = Array.from(document.querySelectorAll('div[role=\"article\"]')); // often the main container for a result\n\n            return items.slice(0, 20).map((item, index) => {\n                // Name is usually in a specialized font style or heading\n                const nameEl = item.querySelector('.fontHeadlineSmall') || item.querySelector('[aria-label]');\n                const name = getText(nameEl) || (item.getAttribute('aria-label') || 'Unknown');\n\n                // Rating often has aria-label \"4.5 stars\"\n                const ratingEl = item.querySelector('[role=\"img\"][aria-label*=\"stars\"]') || item.querySelector('.fontBodyMedium span[role=\"img\"]');\n                const ratingLabel = ratingEl?.getAttribute('aria-label') || '';\n                const ratingMatch = ratingLabel.match(/([0-9.]+)\\s+stars/);\n                const rating = ratingMatch ? parseFloat(ratingMatch[1]) : undefined;\n\n                // Reviews count often follows the rating\n                const reviewsEl = item.querySelector('[aria-label*=\"reviews\"]');\n                const reviewsText = reviewsEl?.getAttribute('aria-label') || getText(reviewsEl);\n                const reviews = reviewsText ? parseInt(reviewsText.replace(/[^0-9]/g, '')) : undefined;\n\n                // Address is inconsistent, but often in the second line of text\n                const container = item.closest('[jsaction]') || item;\n                const textLines = (container as HTMLElement).innerText.split('\\n');\n                const address = textLines.length > 2 ? textLines.find(l => l.match(/\\d+.*,.*\\d+/)) || textLines[2] : '';\n\n                return {\n                    name: name.replace(/\\. \\d+$/, ''), // remove rank suffix if present\n                    rating,\n                    reviews,\n                    address: address || '',\n                    rank: index + 1,\n                };\n            });\n        });\n\n        return results;\n    } catch (error) {\n        console.error(`Scrape failed for ${lat},${lng}:`, error);\n        return [];\n    } finally {\n        await browser.close();\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;;;;;;AAUO,eAAe,UAAU,OAAe,EAAE,GAAW,EAAE,GAAW;IACrE,MAAM,UAAU,MAAM,iLAAQ,CAAC,MAAM,CAAC;QAAE,UAAU;IAAK;IACvD,MAAM,UAAU,MAAM,QAAQ,UAAU,CAAC;QACrC,UAAU;YAAE,OAAO;YAAM,QAAQ;QAAI;QACrC,WAAW;IACf;IAEA,gCAAgC;IAChC,MAAM,QAAQ,gBAAgB,CAAC;QAAC;KAAc;IAC9C,MAAM,QAAQ,cAAc,CAAC;QAAE,UAAU;QAAK,WAAW;IAAI;IAE7D,MAAM,OAAO,MAAM,QAAQ,OAAO;IAElC,IAAI;QACA,0BAA0B;QAC1B,MAAM,KAAK,IAAI,CAAC,CAAC,mCAAmC,EAAE,mBAAmB,SAAS,EAAE,EAAE,IAAI,CAAC,EAAE,IAAI,KAAK,CAAC,EAAE;YACrG,WAAW;YACX,SAAS;QACb;QAEA,wEAAwE;QACxE,IAAI;YACA,MAAM,KAAK,eAAe,CAAC,iBAAiB;gBAAE,SAAS;YAAM;QACjE,EAAE,OAAO,GAAG;YACR,QAAQ,GAAG,CAAC;QAChB;QAEA,oDAAoD;QACpD,MAAM,eAAe;QACrB,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IAAK;YACxB,MAAM,OAAO,MAAM,KAAK,CAAC,CAAC;YAC1B,IAAI,MAAM;gBACN,MAAM,KAAK,QAAQ,CAAC,CAAA,OAAQ,KAAK,SAAS,IAAI;YAClD;YACA,MAAM,KAAK,cAAc,CAAC,OAAO,KAAK,MAAM,KAAK;QACrD;QAEA,2DAA2D;QAC3D,MAAM,UAA0B,MAAM,KAAK,QAAQ,CAAC;YAChD,6BAA6B;YAC7B,MAAM,UAAU,CAAC,KAAuB,IAAI,aAAa,UAAU;YAEnE,MAAM,QAAQ,MAAM,IAAI,CAAC,SAAS,gBAAgB,CAAC,yBAAyB,wCAAwC;YAEpH,OAAO,MAAM,KAAK,CAAC,GAAG,IAAI,GAAG,CAAC,CAAC,MAAM;gBACjC,yDAAyD;gBACzD,MAAM,SAAS,KAAK,aAAa,CAAC,yBAAyB,KAAK,aAAa,CAAC;gBAC9E,MAAM,OAAO,QAAQ,WAAY,KAAK,YAAY,CAAC,iBAAiB;gBAEpE,0CAA0C;gBAC1C,MAAM,WAAW,KAAK,aAAa,CAAC,wCAAwC,KAAK,aAAa,CAAC;gBAC/F,MAAM,cAAc,UAAU,aAAa,iBAAiB;gBAC5D,MAAM,cAAc,YAAY,KAAK,CAAC;gBACtC,MAAM,SAAS,cAAc,WAAW,WAAW,CAAC,EAAE,IAAI;gBAE1D,yCAAyC;gBACzC,MAAM,YAAY,KAAK,aAAa,CAAC;gBACrC,MAAM,cAAc,WAAW,aAAa,iBAAiB,QAAQ;gBACrE,MAAM,UAAU,cAAc,SAAS,YAAY,OAAO,CAAC,WAAW,OAAO;gBAE7E,gEAAgE;gBAChE,MAAM,YAAY,KAAK,OAAO,CAAC,iBAAiB;gBAChD,MAAM,YAAY,AAAC,UAA0B,SAAS,CAAC,KAAK,CAAC;gBAC7D,MAAM,UAAU,UAAU,MAAM,GAAG,IAAI,UAAU,IAAI,CAAC,CAAA,IAAK,EAAE,KAAK,CAAC,mBAAmB,SAAS,CAAC,EAAE,GAAG;gBAErG,OAAO;oBACH,MAAM,KAAK,OAAO,CAAC,WAAW;oBAC9B;oBACA;oBACA,SAAS,WAAW;oBACpB,MAAM,QAAQ;gBAClB;YACJ;QACJ;QAEA,OAAO;IACX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,CAAC,kBAAkB,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,CAAC,EAAE;QAClD,OAAO,EAAE;IACb,SAAU;QACN,MAAM,QAAQ,KAAK;IACvB;AACJ"}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/lib/scanner.ts"],"sourcesContent":["import { prisma } from './prisma';\nimport { generateGrid } from './grid';\nimport { scrapeGMB } from './scraper';\n\nexport async function runScan(scanId: string) {\n    const scan = await prisma.scan.findUnique({\n        where: { id: scanId },\n    });\n\n    if (!scan) throw new Error('Scan not found');\n\n    await prisma.scan.update({\n        where: { id: scanId },\n        data: { status: 'RUNNING' },\n    });\n\n    const points = generateGrid(scan.centerLat, scan.centerLng, scan.radius, scan.gridSize);\n\n    for (const point of points) {\n        console.log(`Scraping point: ${point.lat}, ${point.lng}`);\n        const results = await scrapeGMB(scan.keyword, point.lat, point.lng);\n\n        await prisma.result.create({\n            data: {\n                scanId: scan.id,\n                lat: point.lat,\n                lng: point.lng,\n                topResults: JSON.stringify(results),\n                // Note: targetName rank logic can be added later\n            },\n        });\n\n        // Delay between points to avoid detection\n        await new Promise(resolve => setTimeout(resolve, 2000 + Math.random() * 3000));\n    }\n\n    await prisma.scan.update({\n        where: { id: scanId },\n        data: { status: 'COMPLETED' },\n    });\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;AAEO,eAAe,QAAQ,MAAc;IACxC,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,UAAU,CAAC;QACtC,OAAO;YAAE,IAAI;QAAO;IACxB;IAEA,IAAI,CAAC,MAAM,MAAM,IAAI,MAAM;IAE3B,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;QACrB,OAAO;YAAE,IAAI;QAAO;QACpB,MAAM;YAAE,QAAQ;QAAU;IAC9B;IAEA,MAAM,SAAS,IAAA,oIAAY,EAAC,KAAK,SAAS,EAAE,KAAK,SAAS,EAAE,KAAK,MAAM,EAAE,KAAK,QAAQ;IAEtF,KAAK,MAAM,SAAS,OAAQ;QACxB,QAAQ,GAAG,CAAC,CAAC,gBAAgB,EAAE,MAAM,GAAG,CAAC,EAAE,EAAE,MAAM,GAAG,EAAE;QACxD,MAAM,UAAU,MAAM,IAAA,oIAAS,EAAC,KAAK,OAAO,EAAE,MAAM,GAAG,EAAE,MAAM,GAAG;QAElE,MAAM,gIAAM,CAAC,MAAM,CAAC,MAAM,CAAC;YACvB,MAAM;gBACF,QAAQ,KAAK,EAAE;gBACf,KAAK,MAAM,GAAG;gBACd,KAAK,MAAM,GAAG;gBACd,YAAY,KAAK,SAAS,CAAC;YAE/B;QACJ;QAEA,0CAA0C;QAC1C,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS,OAAO,KAAK,MAAM,KAAK;IAC5E;IAEA,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;QACrB,OAAO;YAAE,IAAI;QAAO;QACpB,MAAM;YAAE,QAAQ;QAAY;IAChC;AACJ"}},
    {"offset": {"line": 248, "column": 0}, "map": {"version":3,"sources":["file:///Users/danish/codeplayground/GMBserp/src/app/api/scans/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { prisma } from '@/lib/prisma';\nimport { runScan } from '@/lib/scanner';\n\nexport async function POST(req: Request) {\n    try {\n        const { keyword, address, radius, gridSize } = await req.json();\n\n        // In a real app, we'd geocode the address. \n        // For this POC, let's use a dummy center if not provided or just hardcode for testing.\n        // Ideally use Google Maps Geocoding API or a free alternative.\n        // LETS GOogle it or assume a fixed one for now or mock it.\n\n        // MOCKING Geocoding Chicago center for now\n        const centerLat = 41.8781;\n        const centerLng = -87.6298;\n\n        const scan = await prisma.scan.create({\n            data: {\n                keyword,\n                centerLat,\n                centerLng,\n                radius: parseFloat(radius),\n                gridSize: parseInt(gridSize),\n                status: 'PENDING',\n            },\n        });\n\n        // Run the scan in the background (fire and forget for now, or use a worker)\n        runScan(scan.id).catch(console.error);\n\n        return NextResponse.json(scan);\n    } catch (error) {\n        console.error('API Error:', error);\n        return NextResponse.json({ error: 'Failed to create scan' }, { status: 500 });\n    }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;;;;;AAEO,eAAe,KAAK,GAAY;IACnC,IAAI;QACA,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAI,IAAI;QAE7D,4CAA4C;QAC5C,uFAAuF;QACvF,+DAA+D;QAC/D,2DAA2D;QAE3D,2CAA2C;QAC3C,MAAM,YAAY;QAClB,MAAM,YAAY,CAAC;QAEnB,MAAM,OAAO,MAAM,gIAAM,CAAC,IAAI,CAAC,MAAM,CAAC;YAClC,MAAM;gBACF;gBACA;gBACA;gBACA,QAAQ,WAAW;gBACnB,UAAU,SAAS;gBACnB,QAAQ;YACZ;QACJ;QAEA,4EAA4E;QAC5E,IAAA,kIAAO,EAAC,KAAK,EAAE,EAAE,KAAK,CAAC,QAAQ,KAAK;QAEpC,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,cAAc;QAC5B,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC/E;AACJ"}}]
}